cpu核心数:线程数= 1:1
cpu核心数:线程数= 1:2(超线程)

并行量:同一时间能够运行的数量
并发量:一段时间内,运行的量

线程:cpu调度执行的最小单位
进程:程序运行分配资源的最小单位

为什么使用并发编程?
	提高cpu的利用率,减少用户等待时间,程序模块化(不同业务,同时没有先后顺序,同时执行几个代码段),异步化

并发编程带来的问题?
	资源是否安全,内存溢出,死锁



多线程实现的方式
	继承Thread:
		
	实现Runnable
		new Thread(Thread继承类).start()
	实现Callable
		有返回值,但是启动方式不是直接用 new Thread(Thread类),而是用new Thread(new FutureTask(Thread类)).start()



AQS:
	AbstractQueuedSynchronizer


并发包中继承了该类的类
	ReentrantLock:
		Sync
		NonfairSync
		FairSync

	ReentrantReadWriteLock
		Sync
		NonfairSync
		FairSync
		ReadLock
		WriteLock

	Semaphore
		Sync
		NonfairSync
		FairSync

	CountDownLatch
		Sync

	ThreadPoolExcuteExecutor



这些都是继承了AQS抽象类
	


在Java中可以概括的锁分类以下几类
	共享锁和排它锁
	公平锁和非公平锁
	可重入锁和非重入锁
	乐观锁和悲观锁

Java的内置的锁:
	synchronized
		排它锁,可重入锁
			优点:使用简单
			缺点:暂用资源非常多,如果一个线程锁的不释放,那么其他锁永远也得不到锁,非常浪费资源,用户交互上,不能够及时响应

并发包提供的锁:
	
	Lock锁:
		共享锁和排他锁都有实现,也可重入
			底层原理:
				cas
				队列(双向链表)
				LockSupport的支持

			优点:可重入,获取锁可被中断,超时获取锁,可以尝试获取锁,可以读写分离锁


与并发相关的类
	CyclicBarrier
	CountDownLatch
	Semaphore
	LockSupport
	Exchange
	Callable/Future/FutrueTask

	ReentrantLock
	ReentrantReadWriteLock

与并发相关的概念
	Fork/Join:分而治之,分成几份,但是每一份都和原来具有同样的意义,然后将结果结合,用到了多线程技术,多线程同时运算

Thread类方法
	join()
	yield()
	sleep()
	setDamon()
	isDamon()
	start()
	run()
	interrupt()
	isInterrupted()


Object类方法
	wait()
	notify()
	notifyAll()


这是都是单体应用中可以使用的,但是如果在分布式中,对于数据库的某张表有多个入口操作(集群的方式),此时这一类锁就没有作用


分布式锁:
	1.redis的setNX()
	2.基于zookeeper的实现*-------